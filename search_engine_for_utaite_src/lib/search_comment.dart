/*
근데 아쉬운게... 검색엔진을 아무리 안 바꿀거라고 해도 그래도 일본어 발음정도는 저장하는게 낫지 않을까?

그러면 이렇게 하자.
일본어를 쳐서 검색할 사람은 없으니...
일단 설명란 이제 안받아온다. 채널명과 색인으로만 승부!!
검색어 태그를 설정할 때
제목을 5가지 포멧으로 저장할 것이다.
아냐...
어떻게 하면 좋을까?
내가 원하는 정확한 그게 안 돼...
구글에서는 어떻게 하지?
결국에 단순 인덱싱만으로는 안된다는거야...
구글에서는 인덱싱 후에 랭킹도 한다고 하고 이것저것 하는게 많다고 한다.
예를들어서 요시노를 요시노라고 검색할수는 없어도
yoshino라고 검색했을때는 나와야될거 아냐...

근데 결국에는 이것도 일본어 표기방법을 따를 뿐이잖아...
그러면 그냥 아싸리 일본어로 다 번역하는건 안되나?
아냐...
흠..........
결국에는 일본어로 바꾸는게 맘이 편할 것 같기는 하네
결국엔 다들 일본어를 쓸거 아녀
그러면 검색하는걸 일본어로 바꾸는게 좋을텐데
그러면 병음을 입력했을 때는 완벽히 될거다

-> 그러니까 뭘 하고자 하는거냐면
일단 제목이 들어와, 그걸 다 일본어로 바꿔
그리고 검색어도 일본어로 바꿔
이러면 비슷한 문장에 대한 걱정이 없어지지!!!
왜? 어차피 일본어로는 하나로 돼있을거거든.
근데 그러면 rumor같은건 어떡하지??
rumor은 소문이라는 뜻의 일본어로 바뀌어버릴건데
우리는 그냥 rumor라고 검색하면 그게 또 일본어로 바뀌고 그러면 되는구나 ㅋㅋㅋㅋ
그러면 이렇게 하자.
3가지 채널로 운영하는거야
처음 제목을 입력받으면
1. 전부 일본어
2. 전부 영어
3. 전부 한국어
이렇게 만든다

하나만 걸려라 마인드인데
이건 한국인을 타겟팅한 앱이잖아
그러니까 이제 인덱싱 잘 해서 주요단어만 뽑는건 한국어에만 적용해주고
그건 나중에 따로 설계하자
영어와 일본어의 예시만 한번 보자

kienai를 검색한다고 치면
이게 원어가 일본어잖아?
그러면 일본어에서 걸리겠지

rumor을 검색한다고 치면
이건 또 원어가 영어잖아?
그러면 영어에서 걸리겠지

이렇게 영어랑 일본어는 끝났는데(각자 원어로 가는거니까)
그러면 남은 문제는 한국어잖아
진흙 속에 피다를 누가 일본어 제목을 외워다니겠어 그치?
그러면...
흠.....................
모르겠긔...
아 근데 이거 말고 다른거 만들고싶은데 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
뭐 만들만한거 없나?
그냥 뭔가... 좀 그래 ㅋㅋㅋ
근데 나는 그 이유를 알 것 같음
그냥 덕질을 너무 안하니까 기부니가 안조은거야
아이디어도 없어지고 ㅇㅇ
그냥 그 뿐임
그게 정설임 미안하지만
쩝....
어쩌지 ㅋㅋㅋㅋㅋ
근데 하는 수 있나, 시작한건 끝내야지
근데 pub.dev찾아보니까 구글에서 플러터 쓰라고 만든 무료 번역 api가 있는 모양
개꿀띠띠가 아닐 수 없긔~~~~

씨발
일본에도 동음이의어가 존나게 많다는걸 망각하고 있었다.
아아아ㅏㅏㅏㅏ 그러면 어떻게 하지????
뜻이 있는건 잘 번역을 한다.
뜻이 없는 것들을 번역 못 하는 것 같다(특히 이름)
그러면 차라리 그냥 뜻이 없는건 알아서 영어로 발음 맞춰서 가겠거니~ 하는게 나으려나?
근데 그러기에는 다즈비의 사례처럼 발음이 줒박았을 수도 있잖아...

그냥 ai를 쓰는게 답일려나

그냥 진짜 임베딩을 쓰는 방법밖에는 없을 것 같네

그러면 사실 이제 언어도 별 상관 없어지니까 몰라레후~ 하고 그냥 구현딸깍 하면 됨.
오픈ai api키를 쓰거나 아니면 저기저기 저 다른 임베딩 계산기 쓰고
유사도 계산하는것만 하면 될 것 같은데?

여기서 더 최적화 하려면 더 자세히 알아야 할 것 같음.
근데 진짜 공부해보고 싶은데????
책이라도 찾아볼까

근데 이거 진짜 재밌겠다...!!!
임베딩 쓰면 여러개의 단어나 문장들을 벡터공간 안에 그냥 표현해버릴 수 있다는거잖아
그 유사도도 만들 수 있고
근데 그걸 보여주고싶은데 그건 안되네... 그 이유는 우리가 이해할 수 있는 최대차원이 3차원이니까...
아쉽구만!

아무튼 임베딩에 대해서 더 공부해보면 해볼만한게 쏟아질 것 같은데????

암튼 일단 지금은 이걸 구현하는데만 신경쓰자.
검색서비스... 어찌해야될지 잘 모르겠네


근데 그니까 일단은 임베딩을 쓸건데, 어떤 임베딩을 쓸거냐???
일단 
1. 나같은 하꼬는 비용걱정 안해도 된다.
2. 일단 그러면 문제는 어떤게 성능이 좋냐인데, 그냥 일단은 쓰기 쉬운거 쓰자.
3. 그러니까 open ai를 쓰자.

근데 생각보다 복잡하긴 하네 그래도 ㅋㅋㅋ...
사람들은 주로 python을 사용하는 듯 하다.
근데 여기서 파이썬을 갑자기 끌어들이면 서버랑 이래저래 복잡해진다.
그러니까 그냥 http api호출로 사용하는 방법을 찾아서 사용하는편이 좋겠다.
자바쪽에서 사용하는걸 찾아보면 좋을 것 같고, 그냥 임베딩 관련된거 해보고싶으면 파이썬 쓰자.

플러터에서 쉽게 사용하는법은 없는 것 같기도...

그러면 파이썬으로 쉽게 가능하다고 하니까
플러터에서 파이썬을 연결할 방법을 찾아보자
지금은 api키 발급까지 했는데 돈이 없어서 실행을 못 하고 있다.
https://seong9566.tistory.com/378
에서 플러터에서 파이썬 코드 실행하는 방법 알려주니 이걸 사용해서 파이썬을 실행하면 될 듯 하다.


결국 현실과 적당히 타협한 선은 이정도다.
1. 원문은 원문으로 검색 가능하다!(아마도 영어겠지)
2. 비슷한 의미의 문장을 적으면 가능하다!
3. 고유명사는 영어로 적어줘요
4. 
*/




/*
여러가지 검색의 경우를
1. 그냥 정직하게 검색(rumor -> rumor, dazbee -> dazbee, 다즈비 -> 다즈비)
2. 일본어로 영어발음을 써놓은 걸 검색(루머 -> ルーマー, rumor -> ルーマー)
3. 한국어로 일본어 발음을 검색(히바나 -> ヒバナ, 요시노 -> 吉乃)
4. 한국어로 영어 발음을 검색(루머 -> rumor, 아도 -> ado)
5. 영어로 일본어 발음을 검색(yoshino -> 吉乃)
6. 같은 의미의 다른언어 검색(내일의 밤하늘 초계반 -> アスノヨゾラ哨戒班)


지금 할 수 있는 것.
- 영어 문장의 유사도 파악
- 챗gpt를 통한 일본어 -> 로마자 변환
- 문장 번역(병음은 완벽하지 않다.)
- 문장을 스플릿하기(일본어는 좀 빡셀수도.)(불러보았습니다, cover 등등 걸러야함)
- 임베딩을 통한 문자의 연관성 파악.
- 문자열 비교
- 사운덱스를 통한 영어 문장의 발음 유사도 파악.


각 케이스를 위한 솔루션.
1. -> 스플릿해서 색인해놓은 단어들에 대조하여 검색한다.
2. -> 일본어 자체를 chatgpt를 통해 로마자로 변환하여놓고, 사운덱스를 통해 유사도 찾자.
3. -> 2번 케이스에서 한국어도 로마자로 변환하여 사운덱스를 통해 유사도 찾자.
4. -> 2번케이스를 한국어로 하자.
5. -> 2번 케이스를 역으로 하자.
6. -> 번역기 돌리고 문장 유사도로 검색하자.


그러기 위해 필요한 것.
1. 영상 제목, 채널명, 검색어 등 인덱싱.(우타이테 전용 색인방법 필요할듯.)
2. 문장 -> 로마자 (chatGPT모델).
3. 문장(단어) -> 사운덱스 코드
4. 번역기
5. 문장 유사도


step. 새로운 영상!
-> 1번 모듈로 색인하여 일단 DB에 저장.
-> 색인한 단어들을 2번 모듈에 넣어서 로마자 저장.
-> 로마자를 3번 모듈에 넣어서 사운덱스 코드 저장.
-> 색인된 것들을 각각 영어로 번역해놓기(완벽하지 않아도 됨.)

step. 검색시!
-> 1번 모듈로 색인하기
-> 색인한 단어들을 2번 모듈에 넣어서 로마자 저장.
-> 3번 모듈로 사운덱스 코드 받기.
-> 영어로 번역하기
-> DB에 있는 사운덱스 코드와 비교 & DB에 있는 영어번역과 유사도 비교하기
-> 내가 설정한 가중치를 통해서 정렬하기




그러기 위해 필요한 것.
1. 영상 제목, 채널명, 검색어 등 인덱싱.(우타이테 전용 색인방법 필요할듯.)
 ㄴ> 내가 직접 플러터로 색인할거임.
2. 문장 -> 로마자 (chatGPT모델).
 ㄴ> chatGPT모델에게 한 번에 "~를 로마자로 변환해줘. 다른 말 없이 로마자만 대답해줘"이런식으로 프롬프트까지 한 번에 보낼 예정.
3. 문장(단어) -> 사운덱스 코드
  ㄴ> 구현하기 쉽다. 그냥 플러터로 구현하거나 라이브러리 쓰면 된다.
4. 번역기
  ㄴ> 이미 다운받아놓은 번역기(구글 무료번역 api를 사용한다고 한다) 사용한다.
5. 문장 유사도
  ㄴ> plagiarism_checker_plus 패키지를 이용할 것이다.



의문: 왜 다 챗지피티가 할 수 있는데 안하나요?
프롬프트를 전달한 커스텀 gpt를 api로 호출하는건 쉽지않아보인다.
그러니 chatGPT에 최소한의 일만 시키는 편이 속도면에서 유리할 것.
*/



/*
모듈 1 구현. 그냥 인덱싱 과정이라고 생각하면 된다.

인덱싱은
텍스트 추출 -> 토큰 추출 -> 불용어 제거 -> 스테밍 등등... 이런 과정을 거친다.
목적은 말 그대로 검색어만 남기기 위함.
그렇지만 내 경우는 검색어만 남길게 아니다.
내일의 밤하늘 초계반을
내일, 밤하늘 이런걸로 검색할게 아니기 때문

그러면 난 뭘 해야하나?
제목 , 우타이테 , 원곡자 
이 3가지만 하면 된다.

그러면 토큰, 스테밍 단계는 거치지 않아도 된다.

그러면 우리가 만나게 될 몇가지 예상 시나리오를 생각하자.
1. UNDEAD (YOASOBI) / 텐코 시부키(Tenko Shibuki) cover
-> (cover) 이 붙어있다, 아주아주 흔한 케이스
2. [심묘] 마음짓기/하나땅
-> 원곡자랑 관련없는 파쿠리 유튜버 이름이 들어갔다.
3. 녹아내려요 하나땅 검은고양이 HD 자막,발음
-> HD, 자막, 가사, 발음 이런거 자주 들어간다.
4. [이어폰 필수]자상무색(自傷無色) jishou mushoku 하나땅 KK 좌우
-> 이어폰 필수, 목소리에 취한다 이런 호들갑 멘트가 있다.
5. 생명에게 미움받고 있어.／마후마후【불러보았다】
-> [불러보았다]가 붙는다.

얘네들을 다 거를거시여
- (), [], /, -등등 모든 특수문자를 제외한다.
- 근데 이걸 그냥 삭제가 아니라 이걸 기준으로 스플릿을 해야될 것 같아.
- 그리고 나서 불용어들을 거르면 좋은데 다 못 걸러도 그걸 검색키워드로 냅둬도 어차피 그걸로
  검색될 일이 없으니 괜찮을 것 같아.
  그냥 리소스를 줄이기 위해 불용어 몇 개를 제거한다고만 생각하자.
- 그런 다음에는 검색어들의 리스트를 만들건데...
  검색어들은 리스트 형태가 될거야. 근데 그걸 쪼개는 기준은 특수문자가 될거고
  만약에 아주 특별한 형태의 제목을 가져서 안 나눠진다면... 아쉬운거지.
  내가 띄어쓰기 하나마다 해줄순 없잖니.

그러면 이제 어떻게 되냐
[UNDEAD, YOASOBI, 텐코 시부키, TENKO Shibuki]
이렇게 되겠지
흠.... 근데 "시부키"라고만 검색하는 경우도 있을 수 있지 않을까
그러면 띄어쓰기마다 나누는게 나은가?
근데 그건 그래
왜냐면 저걸 검색할 때
시부키 언데드, 언데드 시부키, 요아소비 언데드
이런식으로 검색할게 뻔한데
그걸 잡아내려면...
그러면 이런건 어때
저걸 다 하나씩으로 나누는거야 그리고 나서 각자를 비교하는거지
근데 그걸 채널명에 하는건 효과가 있는데 만약에 제목을 그렇게 나누면 의미가 없어지잖아
그러면 나눈것도 가지고 있고, 원본도 가지고있자.
그리고 그중에 가장 매칭점수가 높은걸 하면 되지
그리고 이제 검색어를 입력받을때 우타이테랑 제목은 특수문자로 나눠서 써달라고 하면 되는거지ㅇㅇ

ㅇㅋ 그러면 이제 정리하면
스플릿을 하는데, 그게 고유명사일수도 있으니
띄어쓰기가 있는것들은 원본을 하나, 그리고 띄어쓰기를 전부 구분해서 하나씩 할거다.
그러면 대략 이런 형태가 나올 것이다.

생명에게 미움받고 있어.／마후마후【불러보았다】
-> [생명에게 미움받고 있어, 마후마후, 생명에게, 미움받고, 있어]
이런 형태가 될 것.
그럼 이걸 내가 짜놓은 로직에 통과시킬 수 있게 된다.
그러니 결국에는 키워드 목록을 얻게 된 셈이다.
어떠한 특수형태에도 적용할 수 있다.
제목의 경우에 좀 문제가 될 수도 있다.
예를들면 
[이어폰 필수]자상무색(自傷無色) jishou mushoku 하나땅 KK 좌우
이런 경우에
jishou mushoku는 따로 저장되지 않을것이기 때문이다.
흠...
근데 이런 특이케이스는 사실 정말 거의 없기 때문에 url검색의 힘을 빌리는 편이 좋을 것 같다...ㅋㅋㅋ

모든 단어의 조합을 따질수도 있겠지만, 그건 너무나 비효율적이다.

split의 기준이 될 문자들은 다음과 같다
["/", "-", "(", ")", "[", "]"]

그리고 불용어가 될 목록들은 다음과 같다
["cover", "불러보았다", "불러보았습니다", "불러봤습니다", "歌いました", "covered by", "feat", "가사", "해석", "이어폰", "고음질", "official", "channel"]
(앞으로 더 추가예정)

그리고 빼고 볼, 없앨 문자 목록은 이렇다
[".", ",", " "]
*/

/*
근데 이게... 한국어를 로마자로 변형하고, 메타폰 더블로 변환하고 그 모든 과정이 좀 복잡할 것 같아서...
그냥 이 모든걸 다 gpt한테 맡겨버리자 ㅋㅋㅋㅋㅋㅋ


jp_trans뭐시기 써봤는데 그리 정확하게 해주지 않는다.

어차피 일본어로 검색할 일은 없으니 그냥 빠르게 일본어 처리하는건 관두고 ai시키자.
그리고 검색할때만 korean romaji어찌구 써서 빠르게 변환 후 검색하자.
*/

/*
이제 
module 1 로 키워드 뽑는것도 했고
module 2로 더블 메타폰과 로마자, 번역까지 얻었다.

module 2가 계획에서 했던 모듈 2,3,4역할을 한번에 해줬기 때문에
이제 DB에 저장하는 것만 만들면 그 뒤는 또 검색의 영역이다.

DB에 넣는것, DB에서 가져와서 검색하는것 모두 르브리스와 연결해야하니 곧 연결해야할 것 같다

그 전에 예시 케이스들을 넣고, 검색하는것 까지만 이 repo에서 하자.

그럼 다음에 할 일은 
- 예시 케이스들로 테스트용db모델 만들기
- korean -> romaji 패키지 통한 ai활용보다 빠른 검색.
- 검색 성능 개선
-> 르브리스에 연결!
*/

/*
하... 오늘 진짜 좀 빡셌다.
1. 테스트 케이스 만들던중
2. 파일에 쓰고싶은데 그게 플러터 sdk를 같이 사용하니까 안돼버림.
3. 어차피 module2 플러터 sdk 사용해야하는거 꼴받는데 그냥 다른거 쓰자.
4. 난민마냥 여기저기 존나 다녔는데 해결책 하나도 안보임
5. dotenv가 뭔가 될 것 같은데 예제 따라해도 자꾸 안되고 막 그럼 ㅅㅂ
6. 여기서 이럴줄은 몰랐지만 어차피 env파일 관련이니 ^바이브코딩^ 해버림
7. 이새끼는 또 어디서 정보 가져왔는지 기가막히게 알려줌
8. 그래서 이제 module 2 에 flutter sdk없이도 가능!
*/



/*
한가지 중요한게 한국어로 제목이 쓰여있는 겅우에는 한국어 병음을 사용하게 될 것이다. 그러므로 로마자가 별 의미가...
근데 그건 그냥 포기하자. 진성 웉붕이들이 번역된???한국어??? 제목이 있는 노래를 들을일은 많지 않기 때문에...
*/

/*
근데 이걸 어떤 식으로 르브리스로 옮겨야하지
좀 난감하구만...
그냥 파일을 옮기자.
*/



/*
이제 내가 그동안 계획했던 것들은 다 끝난 것 같다, 이제 하산하자.
이제 다시 르브리스로 넘어간다
2025.09.28
*/

/*
tlqkf
일단은 문제가 "리제"같은 단어를 원래 로마자 규칙대로라면 rije라고 해야하고 실제로 라이브러리에서는 그렇게 한다.
그런데 gpt가 빡통이라 이걸 옆에있는거 가져와서 lize라고 해버린다.
이걸 뭐 잡기도 뭐하고 그래서 그냥 한국어는 ai 안쓰고 그냥 라이브러리로 로마자로 바꾸려고 한다.
그 과정에서 프롬프트를 수정하여 한국어는 남기도록 했는데 그게 안되는 경우들이 있어서 고치는중이다
ai이 빡통색기
*/

/*
근데 생각해보니까 이거 만약에
아카네 리제 라고 인덱싱 된 걸 아카네리제 라고 검색하면 어떻게 됨?
그러면 안되는디.
어차피 검색어 별로 안 길 거 여기저기에 띄어쓰기 박는걸로 해보면 어떨까?
아니면 처음에 인덱싱을 해놓을 때 그냥 띄어쓰기 없는 버전도 해놔?
그것도 나쁘지 않네.
근데 애초에 마지막에 그렇게 현란하게 나눌거면 module1에서는 왜나눴던겨 ㅋㅋㅋㅋ
*/

/*
오전 5:37 지양현 각각 띄어쓰기 만들고 없애고 경우 2개
오전 5:37 지양현 재귀로 해결?
오전 5:37 지양현 그리고 반대로 띄우면 안될 걸 띄운 건…?
오전 5:38 지양현 아니 그니까
오전 5:38 지양현 n개로 나누는거의 조합도 봐야돼…
오전 5:40 지양현 근데 애포에
오전 5:40 지양현 하나의 문자열로 하고
오전 5:40 지양현 마지막에 여러 경우로 다 나눠버리면
오전 5:41 지양현 gpt속도도 빠르고 검색할때도 귀찮게 안 나눠도 되고 좋은거 아닐까?
오전 5:41 지양현 근데 그러면 뭘 제외하냐 안하냐, 띄어쓰기는 어케 하냐 등
오전 5:41 지양현 자유도가 너무 높아져버린다
오전 5:42 지양현 그러면 db용량감당이 힘들어질 것. 
오전 5:42 지양현 그럼 아까 그 모듈1왜있냐는 질문도 해결 가능
오전 5:42 지양현 제목인지 가수인지정도는 알아야 그 안에서 이리저리 나누면서 경우의 수를 줄일 수 있다
오전 6:11 지양현 잠만 근데 생각해보니까
오전 6:11 지양현 이미 띄어쓰기 안 한 게 있네?
오전 6:11 지양현 아 그렇구나
오전 6:12 지양현 근데 그래도 어떻게 띄어쓰기 될 지 모르는거니까…
오전 6:12 지양현 하기는 해야되나?
오전 6:12 지양현 싶긴 한데
오전 6:12 지양현 아니네
오전 6:12 지양현 그냥 나누는것만 있고
오전 6:12 지양현 띄어쓰기는 신경을 안 써도 되네
오전 6:12 지양현 어차피 다 모아서 더블메타폰 만드는데 ㅇㅇ
오전 6:12 지양현 그러면 어떤 조합으로 따로 빼놓을지를 보면 될 듯
오전 6:13 지양현 단순히 띄어쓰기로 하는게 아니라
오전 6:13 지양현 그걸 통한 조합들을 좀 보자
오전 6:13 지양현 원본 키워드 살아있는 상태에서 그거 기반으로
오전 6:13 지양현 그러면
오전 6:13 지양현 띄어쓰기로 세퍼하고
오전 6:14 지양현 그걸로 경우의수 만들어서 더하면 될 것 같은디
오전 6:14 지양현 재귀로 넣을지 뺄지 정하고 ㅇㅇ

근데 이게 의미가 있을 경우가 있을까 과연?
안 그럴 것 같은데 말이야.
몇 번째부터 띄어쓰기 넣기 이런건 의미가 있을 수 있는데
그냥 무작정 조합을 구하는 건 의미가 없을 것 같은데.
*/

/*
일단 버전 2는 이쯤에서 마치자. 이게 이렇게 끝이 나네 ㅋㅋㅋㅋㅎㅎ
쉽게 끝날 줄 알고 시작했는데 생각보다 이것저것 신경쓸것도 많고 여러번 뒤집었구만
그래도 오랜만에 진짜 코딩하는 기분 나서 너무 좋았어
언제 이 repo에 또 들어올지는 모르겠지만 그 떄는 더 멋진 사람이 되어있길 바라며
2025.10.06 AM07:27

--씹파고 완성
*/

/*
ㅎㅇ ㅋㅋㅋㅋㅋㅋ 바로 다음날인데 돌아와버림
음... 알겠지만 이 더블 메타폰은 너무 같은 정도의 점수를 가지는 애들이 많다.
그래서 어쩔 수 없이 그 같은 점수. 동점인 애들의 점수를 나눠줄 수 있는 방법이 필요할 것 같다.
그래서 생각해봤는데, 사운덱스같은 다른 음성 모델을 추가로 사용하는거랑 편집거리를 사용하는 방법이 있어.
어차피 로마자 형태도 저장했는데 편집거리 쓰는게 좋을 것 같기도 하고?

내 생각은 지금 편집거리 쪽으로 기울었는데, 그 이유는 사운덱스는 일단 이름만을 위한거고 어차피 발음을 보는거다.
사운덱스를 좀 더 찾아보는게 좋을 것 같기는 한데
편집거리는 특별히 더 저장할것도 없고 어차피 메타폰으로 한 번 거른 후라면 아예 썡뚱맞은 결과를 가져오지도 않을거기 떄문이다.
적어도 발음이 비슷한것들중에니까... 괜찮을 것 같은데?
*/


/*
지금 이거 바꿔보면서 알았는데 진짜 너무 충격적임
그동안도 마찬가지로 DMP비교는 내가 식을 잘못 쓰는 바람에 대부분의 값이 다 음수가 나오고 있었음.
그래서 지금까지 검색될 때 잘 맞는 일부들로 검색이 되고있던거임.

그래서 다시 식을 쓰고 double point = cnt / input.length;
이거에 맞춰서 translate도 점수 제도를 맞춰줬다. (가중치 w)

이제 1차로 더블 메타폰을 보고
1차에서 동점이였던 애들끼리 그 메타폰이 나온 원본 로마자와 검색어 사이의 편집거리로 한 번 더 순위를 매긴다.
*/